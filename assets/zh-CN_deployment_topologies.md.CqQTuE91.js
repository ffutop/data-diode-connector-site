import{_ as n,I as B,c as d,o as l,a6 as i,b as A,j as t,w as r,a as e,J as E,a8 as o}from"./chunks/framework.Cpr3xyXy.js";const u=JSON.parse('{"title":"部署拓扑与高可用","description":"","frontmatter":{},"headers":[],"relativePath":"zh-CN/deployment_topologies.md","filePath":"zh-CN/deployment_topologies.md","lastUpdated":1764468807000}'),g={name:"zh-CN/deployment_topologies.md"};function f(C,a,p,D,h,c){const s=B("Mermaid");return l(),d("div",null,[a[4]||(a[4]=i('<h1 id="部署拓扑与高可用" tabindex="-1">部署拓扑与高可用 <a class="header-anchor" href="#部署拓扑与高可用" aria-label="Permalink to “部署拓扑与高可用”">​</a></h1><p>在企业级环境中，部署网闸连接器时必须遵循<strong>严格的一对一绑定原则</strong>。本文档概述了基于此核心约束的架构模式与高可用 (HA) 策略。</p><h2 id="核心原则-单一逻辑处理单元" tabindex="-1">核心原则：单一逻辑处理单元 <a class="header-anchor" href="#核心原则-单一逻辑处理单元" aria-label="Permalink to “核心原则：单一逻辑处理单元”">​</a></h2><p>根据网闸连接器的<a href="/zh-CN/protocol">协议设计</a>，<strong>入口代理（Ingress Proxy）与出口代理（Egress Proxy）构成单一的逻辑处理单元</strong>。</p><ul><li><strong>严格的一对一映射</strong>：每一个入口代理实例必须对应一个专属的出口代理实例。</li><li><strong>不可复用</strong>：<strong>不支持</strong>多个入口代理实例的数据由同一个出口代理实例处理，也<strong>不支持</strong>一个入口代理实例分发给多个出口代理实例。</li></ul><h3 id="原理说明" tabindex="-1">原理说明 <a class="header-anchor" href="#原理说明" aria-label="Permalink to “原理说明”">​</a></h3><p>入口代理与出口代理内部维护着针对单一数据流的状态机（包括序列号追踪、分片重组状态）。如果多个入口代理向同一个出口代理发送数据，会导致接收端的序列号冲突和状态混乱，进而导致严重的数据包丢失和重组失败。</p><p>因此，所有的扩展和高可用设计，都必须以<strong>成对出现的入口代理与出口代理</strong>为基本单位。</p><h2 id="部署模式" tabindex="-1">部署模式 <a class="header-anchor" href="#部署模式" aria-label="Permalink to “部署模式”">​</a></h2><p>网闸连接器支持 Kubernetes 和 Docker Compose 部署，但请务必遵循上述配对原则。</p><h3 id="单链路对部署模式" tabindex="-1">单链路对部署模式 <a class="header-anchor" href="#单链路对部署模式" aria-label="Permalink to “单链路对部署模式”">​</a></h3><p>最基础的部署单元</p>',12)),(l(),A(o,null,{default:r(()=>[E(s,{id:"mermaid-45",class:"mermaid",graph:"%25%25%7Binit%3A%20%7B%20%22themeVariables%22%3A%20%7B%20%22clusterBkg%22%3A%20%22%23ffffff%22%2C%20%22clusterBorder%22%3A%20%22%23424242%22%20%7D%7D%7D%25%25%0Agraph%20LR%0A%20%20%20%20A%5B%22%E6%BA%90%E5%BA%94%E7%94%A8%3Cbr%3ESource%20Application%22%5D%20--%3E%20B%5B%22%E5%85%A5%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EIngress%20Proxy%22%5D%0A%20%20%20%20B%20--%3E%20C((%22%E5%8D%95%E5%90%91%E7%BD%91%E9%97%B8%3Cbr%3EData%20Diode%22))%0A%20%20%20%20C%20--%3E%20D%5B%22%E5%87%BA%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EEgress%20Proxy%22%5D%20--%3E%20E%5B%22%E7%9B%AE%E6%A0%87%E5%BA%94%E7%94%A8%3Cbr%3ETarget%20Application%22%5D%0A%20%20%20%20classDef%20darkStyle%20fill%3A%23ffffff%2Cstroke%3A%23424242%2Ccolor%3A%23424242%2Cstroke-width%3A2px%0A%20%20%20%20class%20A%2CB%2CC%2CD%2CE%20darkStyle%3B%0A"})]),fallback:r(()=>[...a[0]||(a[0]=[e(" Loading... ",-1)])]),_:1})),a[5]||(a[5]=t("ul",null,[t("li",null,[t("strong",null,"配置"),e("： "),t("ul",null,[t("li",null,"入口代理配置唯一的目标 UDP 地址/端口。"),t("li",null,"出口代理监听对应的 UDP 端口。")])])],-1)),a[6]||(a[6]=t("h3",{id:"多链路对部署模式",tabindex:"-1"},[e("多链路对部署模式 "),t("a",{class:"header-anchor",href:"#多链路对部署模式","aria-label":"Permalink to “多链路对部署模式”"},"​")],-1)),a[7]||(a[7]=t("p",null,"多链路对部署模式适用于需要同时处理多个数据流的场景，每个链路对负责独立的流量隔离。",-1)),(l(),A(o,null,{default:r(()=>[E(s,{id:"mermaid-71",class:"mermaid",graph:"%25%25%7Binit%3A%20%7B%20%22themeVariables%22%3A%20%7B%20%22clusterBkg%22%3A%20%22%23ffffff%22%2C%20%22clusterBorder%22%3A%20%22%23424242%22%20%7D%7D%7D%25%25%0Agraph%20LR%0A%20%20%20%20C((%22%E5%8D%95%E5%90%91%E7%BD%91%E9%97%B8%3Cbr%3EData%20Diode%22))%0A%0A%20%20%20%20subgraph%20%22%E9%93%BE%E8%B7%AF%E5%AF%B9%201%22%0A%20%20%20%20A1%5B%22%E6%BA%90%E5%BA%94%E7%94%A8%3Cbr%3ESource%20Application%22%5D%0A%20%20%20%20B1%5B%22%E5%85%A5%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EIngress%20Proxy%22%5D%0A%20%20%20%20D1%5B%22%E5%87%BA%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EEgress%20Proxy%22%5D%0A%20%20%20%20E1%5B%22%E7%9B%AE%E6%A0%87%E5%BA%94%E7%94%A8%3Cbr%3ETarget%20Application%22%5D%0A%20%20%20%20end%0A%20%20%20%20subgraph%20%22%E9%93%BE%E8%B7%AF%E5%AF%B9%202%22%0A%20%20%20%20A2%5B%22%E6%BA%90%E5%BA%94%E7%94%A8%3Cbr%3ESource%20Application%22%5D%0A%20%20%20%20B2%5B%22%E5%85%A5%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EIngress%20Proxy%22%5D%0A%20%20%20%20D2%5B%22%E5%87%BA%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EEgress%20Proxy%22%5D%0A%20%20%20%20E2%5B%22%E7%9B%AE%E6%A0%87%E5%BA%94%E7%94%A8%3Cbr%3ETarget%20Application%22%5D%0A%20%20%20%20end%0A%20%20%20%20A1%20--%3E%20B1%20--%3E%20C%20--%3E%20D1%20--%3E%20E1%0A%20%20%20%20A2%20--%3E%20B2%20--%3E%20C%20--%3E%20D2%20--%3E%20E2%0A%0A%20%20%20%20classDef%20darkStyle%20fill%3A%23ffffff%2Cstroke%3A%23424242%2Ccolor%3A%23424242%2Cstroke-width%3A2px%0A%20%20%20%20class%20A1%2CA2%2CB1%2CB2%2CC%2CD1%2CD2%2CE1%2CE2%20darkStyle%3B%0A"})]),fallback:r(()=>[...a[1]||(a[1]=[e(" Loading... ",-1)])]),_:1})),a[8]||(a[8]=i('<ul><li><strong>配置</strong>： <ul><li>每个链路对的入口代理配置唯一的目标 UDP 地址/端口。</li><li>每个出口代理监听对应的 UDP 端口。</li></ul></li></ul><h2 id="高可用策略" tabindex="-1">高可用策略 <a class="header-anchor" href="#高可用策略" aria-label="Permalink to “高可用策略”">​</a></h2><p>鉴于 1:1 的限制，高可用不能通过简单的“后端集群负载均衡”来实现，必须采用<strong>多链路并行</strong>的策略。</p><h3 id="冗余链路模式-active-active-replication" tabindex="-1">冗余链路模式 (Active-Active Replication) <a class="header-anchor" href="#冗余链路模式-active-active-replication" aria-label="Permalink to “冗余链路模式 (Active-Active Replication)”">​</a></h3><p>这是实现<strong>最高可靠性</strong>的推荐架构，容忍任意组件（包括物理网闸硬件）的故障。</p>',5)),(l(),A(o,null,{default:r(()=>[E(s,{id:"mermaid-103",class:"mermaid",graph:"%25%25%7Binit%3A%20%7B%20%22themeVariables%22%3A%20%7B%20%22clusterBkg%22%3A%20%22%23ffffff%22%2C%20%22clusterBorder%22%3A%20%22%23424242%22%20%7D%7D%7D%25%25%0Agraph%20LR%0A%20%20%20%20A%5B%22%E6%BA%90%E5%BA%94%E7%94%A8%3Cbr%3ESource%20Application%22%5D%0A%20%20%20%20E%5B%22%E7%9B%AE%E6%A0%87%E5%BA%94%E7%94%A8%3Cbr%3ETarget%20Application%22%5D%0A%0A%20%20%20%20subgraph%20%22%E9%93%BE%E8%B7%AF%E5%AF%B9%22%0A%20%20%20%20B1%5B%22%E5%85%A5%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EIngress%20Proxy%22%5D%0A%20%20%20%20C1((%22%E5%8D%95%E5%90%91%E7%BD%91%E9%97%B8%3Cbr%3EData%20Diode%22))%0A%20%20%20%20D1%5B%22%E5%87%BA%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EEgress%20Proxy%22%5D%0A%20%20%20%20end%0A%20%20%20%20subgraph%20%22%E5%86%97%E4%BD%99%E9%93%BE%E8%B7%AF%E5%AF%B9%22%0A%20%20%20%20B2%5B%22%E5%86%97%E4%BD%99%E5%85%A5%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EIngress%20Proxy%22%5D%0A%20%20%20%20C2((%22%E5%8D%95%E5%90%91%E7%BD%91%E9%97%B8%3Cbr%3EData%20Diode%22))%0A%20%20%20%20D2%5B%22%E5%86%97%E4%BD%99%E5%87%BA%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EEgress%20Proxy%22%5D%0A%20%20%20%20end%0A%20%20%20%20A%20--%3E%20B1%20--%3E%20C1%20--%3E%20D1%20--%3E%20E%0A%20%20%20%20A%20--%3E%20B2%20--%3E%20C2%20--%3E%20D2%20--%3E%20E%0A%0A%20%20%20%20classDef%20darkStyle%20fill%3A%23ffffff%2Cstroke%3A%23424242%2Ccolor%3A%23424242%2Cstroke-width%3A2px%0A%20%20%20%20class%20A%2CB1%2CB2%2CC1%2CC2%2CD1%2CD2%2CE%20darkStyle%3B%0A"})]),fallback:r(()=>[...a[2]||(a[2]=[e(" Loading... ",-1)])]),_:1})),a[9]||(a[9]=i('<ul><li><strong>流量流向</strong>： <ul><li><strong>源端</strong>：业务应用将同一份数据同时发送给入口代理和冗余入口代理（流量镜像）。</li><li><strong>传输</strong>：两条链路独立传输数据。</li><li><strong>目的端</strong>：目标应用会收到两份数据（分别来自冗余出口代理和出口代理）。</li></ul></li><li><strong>去重要求</strong>：目标业务系统必须具备<strong>去重逻辑</strong>（例如基于业务数据的唯一 ID），以处理重复到达的数据包。</li></ul><h3 id="基于-kafka-分组消费的故障转移模式-active-active-sharding" tabindex="-1">基于 Kafka 分组消费的故障转移模式 (Active-Active Sharding) <a class="header-anchor" href="#基于-kafka-分组消费的故障转移模式-active-active-sharding" aria-label="Permalink to “基于 Kafka 分组消费的故障转移模式 (Active-Active Sharding)”">​</a></h3><p>利用 Kafka 的消费者组机制实现自动的负载分担和故障转移，同时保持 Ingress 输出流的单一性。</p>',3)),(l(),A(o,null,{default:r(()=>[E(s,{id:"mermaid-139",class:"mermaid",graph:"%25%25%7Binit%3A%20%7B%20%22themeVariables%22%3A%20%7B%20%22clusterBkg%22%3A%20%22%23ffffff%22%2C%20%22clusterBorder%22%3A%20%22%23424242%22%20%7D%7D%7D%25%25%0Agraph%20LR%0A%20%20%20%20A%5B%22%E6%BA%90%20Kafka%20%E9%9B%86%E7%BE%A4%3Cbr%3ESource%20Kafka%20Cluster%22%5D%0A%20%20%20%20C((%22%E5%8D%95%E5%90%91%E7%BD%91%E9%97%B8%3Cbr%3EData%20Diode%22))%0A%20%20%20%20E%5B%22%E7%9B%AE%E6%A0%87%20Kafka%20%E9%9B%86%E7%BE%A4%3Cbr%3ETarget%20Kafka%20Cluster%22%5D%0A%0A%20%20%20%20subgraph%20%22%E9%93%BE%E8%B7%AF%E5%AF%B9%201%22%0A%20%20%20%20B1%5B%22%E5%85%A5%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EIngress%20Proxy%22%5D%0A%20%20%20%20D1%5B%22%E5%87%BA%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EEgress%20Proxy%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22%E9%93%BE%E8%B7%AF%E5%AF%B9%202%22%0A%20%20%20%20B2%5B%22%E5%85%A5%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EIngress%20Proxy%22%5D%0A%20%20%20%20D2%5B%22%E5%87%BA%E5%8F%A3%E4%BB%A3%E7%90%86%3Cbr%3EEgress%20Proxy%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20A%20--%22Same%20Consumer%20Group%22--%3E%20B1%20--%3E%20C%20--%3E%20D1%20--%3E%20E%0A%20%20%20%20A%20--%22Same%20Consumer%20Group%22--%3E%20B2%20--%3E%20C%20--%3E%20D2%20--%3E%20E%0A%20%20%20%20classDef%20darkStyle%20fill%3A%23ffffff%2Cstroke%3A%23424242%2Ccolor%3A%23424242%2Cstroke-width%3A2px%0A%20%20%20%20class%20A%2CB1%2CB2%2CC%2CD1%2CD2%2CE%20darkStyle%3B%0A"})]),fallback:r(()=>[...a[3]||(a[3]=[e(" Loading... ",-1)])]),_:1})),a[10]||(a[10]=i('<ul><li><strong>故障转移流程</strong>： <ul><li>正常情况下，Kafka 将 Partition 分流给 链路对 1 和 链路对 2 的入口代理。</li><li>若链路对 1 的入口代理宕机，Kafka 会触发 Rebalance，将原属于链路对 1 的 Partition 重新分配给链路对 2 的入口代理。</li><li>此时，链路对 2 的入口代理承载双倍流量，但对于链路对 2 的出口代理而言，它仍然只接收来自链路对 2 的入口代理 这一单一源头的合法序列数据，<strong>符合 1:1 协议要求</strong>。</li></ul></li><li><strong>前置条件</strong>： <ul><li>每个链路对的入口代理必须作为 Kafka Consumer 运行。</li><li>必须规划足够的物理通道（端口）供每个入口代理-出口代理对使用。</li></ul></li></ul><h3 id="冷备模式-active-passive" tabindex="-1">冷备模式 (Active-Passive) <a class="header-anchor" href="#冷备模式-active-passive" aria-label="Permalink to “冷备模式 (Active-Passive)”">​</a></h3><p>适用于允许秒级中断的场景。</p><ul><li><strong>机制</strong>： <ul><li>利用 Kubernetes 的 <code>Deployment</code> (Replicas=1) 。</li><li>或 Docker Compose 的 <code>restart: always</code>。</li></ul></li><li><strong>故障恢复</strong>：当入口代理或出口代理进程崩溃时，容器编排平台自动重启实例。</li><li><strong>局限</strong>：重启期间数据传输会中断。</li></ul><h2 id="盲发-问题与监控" tabindex="-1">“盲发”问题与监控 <a class="header-anchor" href="#盲发-问题与监控" aria-label="Permalink to ““盲发”问题与监控”">​</a></h2><p>在单向网络中，每个入口代理<strong>无法知道</strong>对应的出口代理是否正常运行。</p><h3 id="缓解策略" tabindex="-1">缓解策略 <a class="header-anchor" href="#缓解策略" aria-label="Permalink to “缓解策略”">​</a></h3><p>由于我们现在采用严格的配对模式，监控变得更加明确：</p><ol><li><p><strong>带外监控 (Out-of-Band Monitoring)</strong>：</p><ul><li>如果条件允许（存在管理网段），应建立外部监控系统同时检查所有入口代理和出口代理的健康状态。</li><li>如果发现任意出口代理挂死，应通过自动化脚本停止对应的入口代理，迫使上游（如 Kafka）将流量转移到健康的链路。</li></ul></li><li><p><strong>心跳检测</strong>：</p><ul><li>协议包含 <code>HeartBeat</code> 消息。出口代理应当监控心跳接收情况，如果长时间未收到入口代理的心跳，应报警提示“链路中断”。</li></ul></li></ol><h2 id="总结建议" tabindex="-1">总结建议 <a class="header-anchor" href="#总结建议" aria-label="Permalink to “总结建议”">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:left;">场景需求</th><th style="text-align:left;">推荐架构</th><th style="text-align:left;">关键配置</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>一般生产环境</strong></td><td style="text-align:left;"><strong>Kafka 分组模式</strong></td><td style="text-align:left;">多个入口代理作为同一消费组进行消费；每个入口代理绑定独立出口代理；依靠 Kafka Rebalance 容错。</td></tr><tr><td style="text-align:left;"><strong>最高可靠性</strong></td><td style="text-align:left;"><strong>冗余链路 (双发)</strong></td><td style="text-align:left;">源端双发流量；部署两套独立链路；目的端去重。</td></tr><tr><td style="text-align:left;"><strong>资源受限/简单</strong></td><td style="text-align:left;"><strong>K8s 冷备</strong></td><td style="text-align:left;">单个 Pod 对；依赖 K8s 自动重启。</td></tr></tbody></table><p><strong>切记</strong>：任何时候扩容，都必须同时增加入口代理和出口代理，并配置独立的通信端口/通道，严禁多对一拓扑。</p>',12))])}const k=n(g,[["render",f]]);export{u as __pageData,k as default};
