import{_ as g,I as c,c as p,o as r,a6 as s,b as o,j as t,w as i,a,J as l,a8 as d}from"./chunks/framework.Cpr3xyXy.js";const D=JSON.parse('{"title":"Deployment Topologies and High Availability","description":"","frontmatter":{},"headers":[],"relativePath":"en/deployment_topologies.md","filePath":"en/deployment_topologies.md","lastUpdated":1764468807000}'),u={name:"en/deployment_topologies.md"};function h(m,e,f,A,y,b){const n=c("Mermaid");return r(),p("div",null,[e[4]||(e[4]=s('<h1 id="deployment-topologies-and-high-availability" tabindex="-1">Deployment Topologies and High Availability <a class="header-anchor" href="#deployment-topologies-and-high-availability" aria-label="Permalink to “Deployment Topologies and High Availability”">​</a></h1><p>In enterprise environments, deploying the Data Diode Connector (DDC) must follow a <strong>strict one-to-one binding principle</strong>. This document outlines architectural patterns and High Availability (HA) strategies based on this core constraint.</p><h2 id="core-architecture-principle-single-logical-processing-unit" tabindex="-1">Core Architecture Principle: Single Logical Processing Unit <a class="header-anchor" href="#core-architecture-principle-single-logical-processing-unit" aria-label="Permalink to “Core Architecture Principle: Single Logical Processing Unit”">​</a></h2><p>According to the <a href="/en/protocol">Protocol Design</a> of the Data Diode Connector, the <strong>Ingress Proxy and Egress Proxy constitute a single logical processing unit</strong>.</p><ul><li><strong>Strict One-to-One Mapping</strong>: Every Ingress Proxy instance must correspond to a dedicated Egress Proxy instance.</li><li><strong>No Reuse</strong>: It does <strong>NOT</strong> support multiple Ingress instances sending to the same Egress instance, nor does it support one Ingress distributing to multiple Egress instances.</li></ul><h3 id="rationale" tabindex="-1">Rationale <a class="header-anchor" href="#rationale" aria-label="Permalink to “Rationale”">​</a></h3><p>The Ingress and Egress proxies maintain a state machine for a single data stream (including sequence number tracking and fragmentation/reassembly state). If multiple Ingress proxies send data to the same Egress proxy, it causes sequence number conflicts and state confusion at the receiver, leading to severe packet loss and reassembly failures.</p><p>Therefore, all scaling and high-availability designs must be based on <strong>paired Ingress and Egress proxies</strong>.</p><h2 id="deployment-patterns" tabindex="-1">Deployment Patterns <a class="header-anchor" href="#deployment-patterns" aria-label="Permalink to “Deployment Patterns”">​</a></h2><p>The Data Diode Connector supports Kubernetes and Docker Compose deployments, but you must strictly adhere to the pairing principle mentioned above.</p><h3 id="single-link-pair-pattern" tabindex="-1">Single Link Pair Pattern <a class="header-anchor" href="#single-link-pair-pattern" aria-label="Permalink to “Single Link Pair Pattern”">​</a></h3><p>The most basic deployment unit.</p>',12)),(r(),o(d,null,{default:i(()=>[l(n,{id:"mermaid-45",class:"mermaid",graph:"%25%25%7Binit%3A%20%7B%20%22themeVariables%22%3A%20%7B%20%22clusterBkg%22%3A%20%22%23ffffff%22%2C%20%22clusterBorder%22%3A%20%22%23424242%22%20%7D%7D%7D%25%25%0Agraph%20LR%0A%20%20%20%20A%5B%22Source%20Application%22%5D%20--%3E%20B%5B%22Ingress%20Proxy%22%5D%0A%20%20%20%20B%20--%3E%20C((%22Data%20Diode%22))%0A%20%20%20%20C%20--%3E%20D%5B%22Egress%20Proxy%22%5D%20--%3E%20E%5B%22Target%20Application%22%5D%0A%20%20%20%20classDef%20darkStyle%20fill%3A%23ffffff%2Cstroke%3A%23424242%2Ccolor%3A%23424242%2Cstroke-width%3A2px%0A%20%20%20%20class%20A%2CB%2CC%2CD%2CE%20darkStyle%3B%0A"})]),fallback:i(()=>[...e[0]||(e[0]=[a(" Loading... ",-1)])]),_:1})),e[5]||(e[5]=t("ul",null,[t("li",null,[t("strong",null,"Configuration"),a(": "),t("ul",null,[t("li",null,"The Ingress Proxy is configured with a unique destination UDP address/port."),t("li",null,"The Egress Proxy listens on the corresponding UDP port.")])])],-1)),e[6]||(e[6]=t("h3",{id:"multi-link-pair-pattern",tabindex:"-1"},[a("Multi-Link Pair Pattern "),t("a",{class:"header-anchor",href:"#multi-link-pair-pattern","aria-label":"Permalink to “Multi-Link Pair Pattern”"},"​")],-1)),e[7]||(e[7]=t("p",null,"The Multi-Link Pair pattern is suitable for scenarios requiring simultaneous processing of multiple data streams, where each link pair is responsible for independent traffic isolation.",-1)),(r(),o(d,null,{default:i(()=>[l(n,{id:"mermaid-71",class:"mermaid",graph:"%25%25%7Binit%3A%20%7B%20%22themeVariables%22%3A%20%7B%20%22clusterBkg%22%3A%20%22%23ffffff%22%2C%20%22clusterBorder%22%3A%20%22%23424242%22%20%7D%7D%7D%25%25%0Agraph%20LR%0A%20%20%20%20C((%22Data%20Diode%22))%0A%0A%20%20%20%20subgraph%20%22Link%20Pair%201%22%0A%20%20%20%20A1%5B%22Source%20Application%22%5D%0A%20%20%20%20B1%5B%22Ingress%20Proxy%22%5D%0A%20%20%20%20D1%5B%22Egress%20Proxy%22%5D%0A%20%20%20%20E1%5B%22Target%20Application%22%5D%0A%20%20%20%20end%0A%20%20%20%20subgraph%20%22Link%20Pair%202%22%0A%20%20%20%20A2%5B%22Source%20Application%22%5D%0A%20%20%20%20B2%5B%22Ingress%20Proxy%22%5D%0A%20%20%20%20D2%5B%22Egress%20Proxy%22%5D%0A%20%20%20%20E2%5B%22Target%20Application%22%5D%0A%20%20%20%20end%0A%20%20%20%20A1%20--%3E%20B1%20--%3E%20C%20--%3E%20D1%20--%3E%20E1%0A%20%20%20%20A2%20--%3E%20B2%20--%3E%20C%20--%3E%20D2%20--%3E%20E2%0A%0A%20%20%20%20classDef%20darkStyle%20fill%3A%23ffffff%2Cstroke%3A%23424242%2Ccolor%3A%23424242%2Cstroke-width%3A2px%0A%20%20%20%20class%20A1%2CA2%2CB1%2CB2%2CC%2CD1%2CD2%2CE1%2CE2%20darkStyle%3B%0A"})]),fallback:i(()=>[...e[1]||(e[1]=[a(" Loading... ",-1)])]),_:1})),e[8]||(e[8]=s('<ul><li><strong>Configuration</strong>: <ul><li>The Ingress Proxy of each link pair is configured with a unique destination UDP address/port.</li><li>Each Egress Proxy listens on its corresponding UDP port.</li></ul></li></ul><h2 id="high-availability-ha-strategies" tabindex="-1">High Availability (HA) Strategies <a class="header-anchor" href="#high-availability-ha-strategies" aria-label="Permalink to “High Availability (HA) Strategies”">​</a></h2><p>Given the 1:1 restriction, High Availability cannot be achieved through simple &quot;backend cluster load balancing&quot;; it must adopt a <strong>multi-link parallel</strong> strategy.</p><h3 id="redundant-link-mode-active-active-replication" tabindex="-1">Redundant Link Mode (Active-Active Replication) <a class="header-anchor" href="#redundant-link-mode-active-active-replication" aria-label="Permalink to “Redundant Link Mode (Active-Active Replication)”">​</a></h3><p>This is the recommended architecture for <strong>maximum reliability</strong>, tolerating failures of any component (including physical data diode hardware).</p>',5)),(r(),o(d,null,{default:i(()=>[l(n,{id:"mermaid-103",class:"mermaid",graph:"%25%25%7Binit%3A%20%7B%20%22themeVariables%22%3A%20%7B%20%22clusterBkg%22%3A%20%22%23ffffff%22%2C%20%22clusterBorder%22%3A%20%22%23424242%22%20%7D%7D%7D%25%25%0Agraph%20LR%0A%20%20%20%20A%5B%22Source%20Application%22%5D%0A%20%20%20%20E%5B%22Target%20Application%22%5D%0A%0A%20%20%20%20subgraph%20%22Link%20Pair%22%0A%20%20%20%20B1%5B%22Ingress%20Proxy%22%5D%0A%20%20%20%20C1((%22Data%20Diode%22))%0A%20%20%20%20D1%5B%22Egress%20Proxy%22%5D%0A%20%20%20%20end%0A%20%20%20%20subgraph%20%22Redundant%20Link%20Pair%22%0A%20%20%20%20B2%5B%22Redundant%20Ingress%20Proxy%22%5D%0A%20%20%20%20C2((%22Data%20Diode%22))%0A%20%20%20%20D2%5B%22Redundant%20Egress%20Proxy%22%5D%0A%20%20%20%20end%0A%20%20%20%20A%20--%3E%20B1%20--%3E%20C1%20--%3E%20D1%20--%3E%20E%0A%20%20%20%20A%20--%3E%20B2%20--%3E%20C2%20--%3E%20D2%20--%3E%20E%0A%0A%20%20%20%20classDef%20darkStyle%20fill%3A%23ffffff%2Cstroke%3A%23424242%2Ccolor%3A%23424242%2Cstroke-width%3A2px%0A%20%20%20%20class%20A%2CB1%2CB2%2CC1%2CC2%2CD1%2CD2%2CE%20darkStyle%3B%0A"})]),fallback:i(()=>[...e[2]||(e[2]=[a(" Loading... ",-1)])]),_:1})),e[9]||(e[9]=s('<ul><li><strong>Traffic Flow</strong>: <ul><li><strong>Source</strong>: The business application sends the same data to both the Ingress Proxy and the Redundant Ingress Proxy simultaneously (Traffic Mirroring).</li><li><strong>Transmission</strong>: The two links transmit data independently.</li><li><strong>Destination</strong>: The target application receives two copies of the data (from the Redundant Egress Proxy and the Egress Proxy respectively).</li></ul></li><li><strong>Deduplication Requirement</strong>: The target business system must have <strong>deduplication logic</strong> (e.g., based on unique IDs in the business data) to handle duplicate data packets arriving from both paths.</li></ul><h3 id="kafka-consumer-group-failover-mode-active-active-sharding" tabindex="-1">Kafka Consumer Group Failover Mode (Active-Active Sharding) <a class="header-anchor" href="#kafka-consumer-group-failover-mode-active-active-sharding" aria-label="Permalink to “Kafka Consumer Group Failover Mode (Active-Active Sharding)”">​</a></h3><p>Leverages Kafka&#39;s consumer group mechanism to achieve automatic load distribution and failover, while maintaining the singularity of the Ingress output stream.</p>',3)),(r(),o(d,null,{default:i(()=>[l(n,{id:"mermaid-139",class:"mermaid",graph:"%25%25%7Binit%3A%20%7B%20%22themeVariables%22%3A%20%7B%20%22clusterBkg%22%3A%20%22%23ffffff%22%2C%20%22clusterBorder%22%3A%20%22%23424242%22%20%7D%7D%7D%25%25%0Agraph%20LR%0A%20%20%20%20A%5B%22Source%20Kafka%20Cluster%22%5D%0A%20%20%20%20C((%22Data%20Diode%22))%0A%20%20%20%20E%5B%22Target%20Kafka%20Cluster%22%5D%0A%0A%20%20%20%20subgraph%20%22Link%20Pair%201%22%0A%20%20%20%20B1%5B%22Ingress%20Proxy%22%5D%0A%20%20%20%20D1%5B%22Egress%20Proxy%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22Link%20Pair%202%22%0A%20%20%20%20B2%5B%22Ingress%20Proxy%22%5D%0A%20%20%20%20D2%5B%22Egress%20Proxy%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20A%20--%22Same%20Consumer%20Group%22--%3E%20B1%20--%3E%20C%20--%3E%20D1%20--%3E%20E%0A%20%20%20%20A%20--%22Same%20Consumer%20Group%22--%3E%20B2%20--%3E%20C%20--%3E%20D2%20--%3E%20E%0A%20%20%20%20classDef%20darkStyle%20fill%3A%23ffffff%2Cstroke%3A%23424242%2Ccolor%3A%23424242%2Cstroke-width%3A2px%0A%20%20%20%20class%20A%2CB1%2CB2%2CC%2CD1%2CD2%2CE%20darkStyle%3B%0A"})]),fallback:i(()=>[...e[3]||(e[3]=[a(" Loading... ",-1)])]),_:1})),e[10]||(e[10]=s('<ul><li><strong>Failover Process</strong>: <ul><li>Under normal circumstances, Kafka distributes Partitions to the Ingress Proxies of Link Pair 1 and Link Pair 2.</li><li>If the Ingress Proxy of Link Pair 1 crashes, Kafka triggers a Rebalance, reassigning the Partitions originally belonging to Link Pair 1 to the Ingress Proxy of Link Pair 2.</li><li>At this point, the Ingress Proxy of Link Pair 2 carries double the traffic, but for the Egress Proxy of Link Pair 2, it still receives valid sequential data from a single source (Link Pair 2&#39;s Ingress), <strong>complying with the 1:1 protocol requirement</strong>.</li></ul></li><li><strong>Prerequisites</strong>: <ul><li>The Ingress Proxy of each link pair must run as a Kafka Consumer.</li><li>Sufficient physical channels (ports) must be planned for use by each Ingress-Egress pair.</li></ul></li></ul><h3 id="cold-standby-mode-active-passive" tabindex="-1">Cold Standby Mode (Active-Passive) <a class="header-anchor" href="#cold-standby-mode-active-passive" aria-label="Permalink to “Cold Standby Mode (Active-Passive)”">​</a></h3><p>Suitable for scenarios where momentary downtime (seconds) is acceptable.</p><ul><li><strong>Mechanism</strong>: <ul><li>Use Kubernetes <code>Deployment</code> (Replicas=1).</li><li>Or Docker Compose with <code>restart: always</code>.</li></ul></li><li><strong>Failure Recovery</strong>: When an Ingress or Egress proxy process crashes, the container orchestration platform automatically restarts the instance.</li><li><strong>Limitations</strong>: Data transmission is interrupted during the restart.</li></ul><h2 id="the-blind-sender-problem-monitoring" tabindex="-1">The &quot;Blind Sender&quot; Problem &amp; Monitoring <a class="header-anchor" href="#the-blind-sender-problem-monitoring" aria-label="Permalink to “The &quot;Blind Sender&quot; Problem &amp; Monitoring”">​</a></h2><p>In a unidirectional network, each Ingress Proxy <strong>cannot know</strong> if its corresponding Egress Proxy is functioning correctly.</p><h3 id="mitigation-strategies" tabindex="-1">Mitigation Strategies <a class="header-anchor" href="#mitigation-strategies" aria-label="Permalink to “Mitigation Strategies”">​</a></h3><p>Since we now adopt a strict pairing pattern, monitoring becomes more explicit:</p><ol><li><p><strong>Out-of-Band Monitoring</strong>:</p><ul><li>If conditions permit (e.g., existence of a management network segment), an external monitoring system should be established to check the health status of all Ingress and Egress proxies simultaneously.</li><li>If any Egress Proxy is found to be down, an automated script should stop the corresponding Ingress Proxy, forcing the upstream (e.g., Kafka) to shift traffic to a healthy link.</li></ul></li><li><p><strong>Heartbeat Detection</strong>:</p><ul><li>The protocol includes <code>HeartBeat</code> messages. The Egress Proxy should monitor the receipt of heartbeats. If no heartbeat is received from the Ingress Proxy for a long time, it should raise an alarm indicating &quot;Link Interrupted&quot;.</li></ul></li></ol><h2 id="summary-recommendations" tabindex="-1">Summary Recommendations <a class="header-anchor" href="#summary-recommendations" aria-label="Permalink to “Summary Recommendations”">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:left;">Requirement</th><th style="text-align:left;">Recommended Architecture</th><th style="text-align:left;">Key Configuration</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Standard Production</strong></td><td style="text-align:left;"><strong>Kafka Group Mode</strong></td><td style="text-align:left;">Multiple Ingress Proxies consume as the same group; each Ingress binds to an independent Egress; relies on Kafka Rebalance for fault tolerance.</td></tr><tr><td style="text-align:left;"><strong>Maximum Reliability</strong></td><td style="text-align:left;"><strong>Redundant Link (Dual Send)</strong></td><td style="text-align:left;">Source sends dual traffic; deploy two independent links; destination handles deduplication.</td></tr><tr><td style="text-align:left;"><strong>Resource Constrained/Simple</strong></td><td style="text-align:left;"><strong>K8s Cold Standby</strong></td><td style="text-align:left;">Single Pod pair; relies on K8s auto-restart.</td></tr></tbody></table><p><strong>Note</strong>: Whenever scaling, you must increase both Ingress and Egress proxies simultaneously and configure independent communication ports/channels. Multi-to-one topology is strictly prohibited.</p>',12))])}const k=g(u,[["render",h]]);export{D as __pageData,k as default};
