import{_ as s,I as o,c as n,o as t,a6 as r,b as l,w as a,a as d,J as c,a8 as h}from"./chunks/framework.Cpr3xyXy.js";const v=JSON.parse('{"title":"Software Architecture","description":"","frontmatter":{},"headers":[],"relativePath":"en/software_architecture.md","filePath":"en/software_architecture.md","lastUpdated":1764468807000}'),f={name:"en/software_architecture.md"};function p(g,e,m,u,x,b){const i=o("Mermaid");return t(),n("div",null,[e[1]||(e[1]=r('<h1 id="software-architecture" tabindex="-1">Software Architecture <a class="header-anchor" href="#software-architecture" aria-label="Permalink to “Software Architecture”">​</a></h1><p>The Data Diode Connector (DDC) is designed as a high-performance, modular software suite that facilitates secure, unidirectional data transfer. This document outlines the software architecture, component interactions, and data flow principles that drive the system.</p><h2 id="high-level-overview" tabindex="-1">High-Level Overview <a class="header-anchor" href="#high-level-overview" aria-label="Permalink to “High-Level Overview”">​</a></h2><div class="relative bg-zinc-50/50 border border-zinc-200 rounded-xl my-8 overflow-hidden"><div class="absolute inset-0 opacity-[0.03]" style="background-image:radial-gradient(#000 1px, transparent 1px);background-size:24px 24px;"></div><div class="relative flex flex-col lg:flex-row items-center justify-center gap-8 p-8"><div class="flex flex-col items-center gap-4 z-10 w-full lg:w-auto flex-1"><div class="w-full bg-white rounded-xl border border-zinc-200 shadow-sm p-6 hover:shadow-md transition-shadow"><div class="flex items-center gap-3 mb-4"><div class="p-2 bg-zinc-100 rounded-lg"><i class="fa-solid fa-cloud-arrow-down text-zinc-700"></i></div><div><h3 class="font-semibold text-sm text-zinc-900 !my-0">Ingress Proxy</h3><p class="text-xs text-zinc-500 !my-0">High Security Side</p></div></div><div class="flex flex-wrap justify-start gap-2"><div class="bg-zinc-50 border border-dashed border-zinc-200 rounded flex items-center justify-center px-3 py-2 text-xs text-zinc-500 flex-grow whitespace-nowrap"><i class="fa-brands fa-docker mr-2"></i> Protocol Handler </div><div class="bg-zinc-50 border border-dashed border-zinc-200 rounded flex items-center justify-center px-3 py-2 text-xs text-zinc-500 flex-grow whitespace-nowrap"><i class="fa-solid fa-filter mr-2"></i> Filter Chain </div><div class="bg-zinc-900 text-white rounded flex items-center justify-center px-3 py-2 text-xs font-mono flex-grow whitespace-nowrap"><i class="fa-solid fa-compress-alt mr-2"></i> UDP Encoder </div></div></div></div><div class="flex flex-col items-center gap-2 z-10 flex-shrink-0"><div class="text-xs font-mono text-zinc-400 uppercase tracking-wider mb-1">One Way</div><div class="flex flex-col lg:flex-row items-center gap-0"><div class="w-[2px] h-8 lg:w-16 lg:h-[2px] bg-zinc-300"></div><div class="h-12 w-12 bg-white border-2 border-zinc-900 rounded-full flex items-center justify-center shadow-xl z-20"><i class="fa-solid fa-arrow-down lg:fa-arrow-right text-zinc-900"></i></div><div class="w-[2px] h-8 lg:w-16 lg:h-[2px] bg-zinc-300"></div></div><div class="text-xs font-medium text-zinc-500 mt-2">Network Gap</div></div><div class="flex flex-col items-center gap-4 z-10 w-full lg:w-auto flex-1"><div class="w-full bg-white rounded-xl border border-zinc-200 shadow-sm p-6 hover:shadow-md transition-shadow"><div class="flex items-center gap-3 mb-4"><div class="p-2 bg-zinc-100 rounded-lg"><i class="fa-solid fa-cloud-arrow-up text-zinc-700"></i></div><div><h3 class="font-semibold text-sm text-zinc-900 !my-0">Egress Proxy</h3><p class="text-xs text-zinc-500 !my-0">Low Security Side</p></div></div><div class="flex flex-wrap justify-start gap-2"><div class="bg-zinc-900 text-white rounded flex items-center justify-center px-3 py-2 text-xs font-mono flex-grow whitespace-nowrap"><i class="fa-solid fa-expand-alt mr-2"></i> UDP Decoder </div><div class="bg-zinc-50 border border-dashed border-zinc-200 rounded flex items-center justify-center px-3 py-2 text-xs text-zinc-500 flex-grow whitespace-nowrap"><i class="fa-solid fa-rotate mr-2"></i> Protocol Rebuilder </div><div class="bg-zinc-50 border border-dashed border-zinc-200 rounded flex items-center justify-center px-3 py-2 text-xs text-zinc-500 flex-grow whitespace-nowrap"><i class="fa-solid fa-paper-plane mr-2"></i> Destination </div></div></div></div></div></div><p>The DDC software is split into two distinct, independent applications that never communicate bi-directionally:</p><ol><li><strong>Ingress Proxy (Sender)</strong>: Resides on the High-Security Network (Source). It consumes data from sources (Kafka, UDP, etc.), optionally filters it, and pushes it across the data diode.</li><li><strong>Egress Proxy (Receiver)</strong>: Resides on the Low-Security Network (Destination). It listens for data coming from the diode, reassembles it, and delivers it to the target systems.</li></ol><p>Both applications share a common core framework written in <strong>Rust</strong>, prioritizing memory safety, zero-copy data handling, and high concurrency.</p><h2 id="the-pipeline-model" tabindex="-1">The Pipeline Model <a class="header-anchor" href="#the-pipeline-model" aria-label="Permalink to “The Pipeline Model”">​</a></h2><p>Internally, both Ingress and Egress proxies operate on a <strong>Pipeline (Chain)</strong> model. A &quot;Chain&quot; defines a single data stream&#39;s path through the software. You can run multiple chains in parallel within a single process (e.g., multiple Kafka topics being transferred simultaneously).</p><p>A Chain consists of three distinct stages connected by high-performance Ring Buffers (<code>BipBuffer</code>):</p>',10)),(t(),l(h,null,{default:a(()=>[c(i,{id:"mermaid-37",class:"mermaid",graph:"%25%25%7Binit%3A%20%7B%20%22themeVariables%22%3A%20%7B%20%22clusterBkg%22%3A%20%22%23ffffff%22%2C%20%22clusterBorder%22%3A%20%22%23424242%22%20%7D%7D%7D%25%25%0Agraph%20LR%0A%20%20%20%20A%5BProtocol%20Handler%5D%20--%3E%7CBipBuffer%7C%20B%5BFilter%20Handler%5D%0A%20%20%20%20B%20--%3E%7CBipBuffer%7C%20C%5BTransport%20Handler%5D%0A%20%20%20%20classDef%20darkStyle%20fill%3A%23ffffff%2Cstroke%3A%23424242%2Ccolor%3A%23424242%2Cstroke-width%3A2px%0A%20%20%20%20class%20A%2CB%2CC%20darkStyle%3B%0A"})]),fallback:a(()=>[...e[0]||(e[0]=[d(" Loading... ",-1)])]),_:1})),e[2]||(e[2]=r('<h3 id="_1-protocol-handler" tabindex="-1">1. Protocol Handler <a class="header-anchor" href="#_1-protocol-handler" aria-label="Permalink to “1. Protocol Handler”">​</a></h3><p>The <strong>Protocol Handler</strong> is the interface to the external world.</p><ul><li><strong>Ingress Side</strong>: It acts as a <em>Consumer</em>. It connects to the source system (e.g., connects to a Kafka Broker, binds a UDP port) and reads data. It normalizes this data into a standard internal binary format.</li><li><strong>Egress Side</strong>: It acts as a <em>Producer</em>. It takes the normalized data from the DDC pipeline and formats it for the destination system (e.g., produces messages to a Kafka Broker, sends UDP packets).</li></ul><h3 id="_2-filter-handler-optional" tabindex="-1">2. Filter Handler (Optional) <a class="header-anchor" href="#_2-filter-handler-optional" aria-label="Permalink to “2. Filter Handler (Optional)”">​</a></h3><p>The <strong>Filter Handler</strong> sits in the middle and enforces security policies. It inspects the raw data payload before it is passed to the transport layer.</p><ul><li><strong>Function</strong>: Content inspection, validation, sanitization, or blocking.</li><li><strong>Behavior</strong>: If a packet violates the rule (e.g., contains a &quot;SECRET&quot; keyword), it is dropped immediately and logged.</li><li><strong>Chaining</strong>: Multiple filters can be chained together, each enforcing a different policy.</li></ul><h3 id="_3-transport-handler" tabindex="-1">3. Transport Handler <a class="header-anchor" href="#_3-transport-handler" aria-label="Permalink to “3. Transport Handler”">​</a></h3><p>The <strong>Transport Handler</strong> manages the actual transmission across the air gap / diode.</p><ul><li><strong>Ingress Side (<code>transport-udp-send</code>)</strong>: Takes data from the buffer, fragments it into UDP packets, adds sequence headers, and blasts it to the diode interface. It implements rate limiting (<code>send_delay_ms</code>) to prevent overwhelming the hardware.</li><li><strong>Egress Side (<code>transport-udp-receive</code>)</strong>: Listens on the diode interface, re-orders packets, checks for gaps (sequence numbers), reassembles the fragments, and writes the complete payload to the next buffer.</li></ul><h2 id="data-flow-memory-management" tabindex="-1">Data Flow &amp; Memory Management <a class="header-anchor" href="#data-flow-memory-management" aria-label="Permalink to “Data Flow &amp; Memory Management”">​</a></h2><p>Performance is critical in a data diode environment because the link is often a bottleneck, and there is no &quot;back-pressure&quot; mechanism (TCP Flow Control) available across the gap.</p><h3 id="lock-free-buffering-bipbuffer" tabindex="-1">Lock-Free Buffering (<code>BipBuffer</code>) <a class="header-anchor" href="#lock-free-buffering-bipbuffer" aria-label="Permalink to “Lock-Free Buffering (BipBuffer)”">​</a></h3><p>DDC uses <strong>SPSC (Single Producer Single Consumer) BipBuffers</strong> (Bipartite Buffers) to pass data between threads.</p><ul><li><strong>Zero-Allocation</strong>: Buffers are pre-allocated at startup.</li><li><strong>Lock-Free</strong>: No Mutexes or Semaphores are used in the hot path, ensuring predictable latency.</li><li><strong>Block/Overwrite</strong>: If the buffer is full (e.g., the Diode is slower than the Kafka source), the Protocol Handler can be configured to either block or overwrite, effectively acting as a software buffer to absorb bursts.</li></ul><h3 id="threading-model" tabindex="-1">Threading Model <a class="header-anchor" href="#threading-model" aria-label="Permalink to “Threading Model”">​</a></h3><p>Each stage of the chain runs in its own dedicated OS thread.</p><ul><li><strong>Protocol Thread</strong>: Handles I/O with the external system.</li><li><strong>Filter/Logic Thread</strong>: Processes CPU-intensive validation.</li><li><strong>Transport Thread</strong>: Dedicated to saturating the network link.</li></ul><p>This separation ensures that a slow filter logic does not necessarily block the network socket immediately, allowing the buffers to absorb the jitter.</p><h2 id="key-design-decisions" tabindex="-1">Key Design Decisions <a class="header-anchor" href="#key-design-decisions" aria-label="Permalink to “Key Design Decisions”">​</a></h2><ol><li><strong>Stateless Core</strong>: The core logic maintains minimal state. State related to packet reassembly is transient and discarded upon error to prevent memory leaks.</li><li><strong>Panic-Proofing</strong>: The architecture is designed to be resilient. Providing error wrapping (using <code>error_chain</code>) to ensure that recoverable errors (like a temporary network glitch) do not crash the entire service.</li><li><strong>Configurable Latency vs. Throughput</strong>: Through <code>bip_buffer_element_count</code> and <code>send_delay_ms</code>, operators can tune the system for low latency (small buffers, low delay) or high throughput (large buffers, batched sends).</li></ol>',20))])}const y=s(f,[["render",p]]);export{v as __pageData,y as default};
