import{_ as i,c as a,o as e,a6 as n}from"./chunks/framework.Cpr3xyXy.js";const c=JSON.parse('{"title":"网闸连接器内核级性能调优 - 10Gbps 线速优化","description":"网闸连接器 (DDC) 在 Linux 下的高性能调优指南。涵盖 UDP Socket 缓冲区 (`rmem_max`)、CPU 亲和性绑定、网卡 (NIC) 卸载及中断合并策略，助力实现 10Gbps 线速传输。","frontmatter":{"title":"网闸连接器内核级性能调优 - 10Gbps 线速优化","description":"网闸连接器 (DDC) 在 Linux 下的高性能调优指南。涵盖 UDP Socket 缓冲区 (`rmem_max`)、CPU 亲和性绑定、网卡 (NIC) 卸载及中断合并策略，助力实现 10Gbps 线速传输。","head":[["meta",{"name":"keywords","content":"Linux内核调优, UDP性能优化, 网卡中断亲和性, CPU绑定, NIC卸载, GRO/GSO, 10Gbps线速, rmem_max"}]],"seo":{"proficiencyLevel":"Expert","keywords":["Kernel Tuning","UDP Optimization","CPU Affinity","NIC Offloading","10Gbps Networking"]}},"headers":[],"relativePath":"zh-CN/kernel_tuning.md","filePath":"zh-CN/kernel_tuning.md","lastUpdated":1764595667000}'),t={name:"zh-CN/kernel_tuning.md"};function l(h,s,p,k,r,d){return e(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="linux-内核级性能调优指南" tabindex="-1">Linux 内核级性能调优指南 <a class="header-anchor" href="#linux-内核级性能调优指南" aria-label="Permalink to “Linux 内核级性能调优指南”">​</a></h1><p>尽管网闸连接器通过 Rust 实现、<a href="/zh-CN/software_architecture#无锁缓冲-bipbuffer">无锁缓冲区</a>和高效数据处理被设计为高性能应用，但要达到最大的吞吐量，尤其是在 <strong>1Gbps 或 10Gbps 的线速 (Line Rate)</strong> 下，通常需要对底层操作系统内核进行调优。网闸连接器在用户空间应用层运行，但其性能从根本上受限于 Linux 内核处理网络数据包和 CPU 资源的效率。</p><p>本指南重点介绍可能显著影响网闸连接器基于 <a href="/zh-CN/protocol">UDP 传输</a>性能的 Linux 内核参数和系统配置。</p><h2 id="udp-socket-缓冲区大小" tabindex="-1">UDP Socket 缓冲区大小 <a class="header-anchor" href="#udp-socket-缓冲区大小" aria-label="Permalink to “UDP Socket 缓冲区大小”">​</a></h2><p>高速 UDP 应用最常见的瓶颈是内核为 UDP Socket 分配的默认缓冲区大小。如果内核的接收缓冲区在网闸连接器（或任何用户空间应用）读取数据包之前就已填满，内核将静默丢弃传入的数据包。同样，一个小的发送缓冲区会限制网闸连接器可以排队传输的数据量。</p><h3 id="关键-sysctl-参数" tabindex="-1">关键 <code>sysctl</code> 参数： <a class="header-anchor" href="#关键-sysctl-参数" aria-label="Permalink to “关键 sysctl 参数：”">​</a></h3><ul><li><strong><code>net.core.rmem_max</code></strong>：所有类型 Socket 的最大接收缓冲区大小（字节）。</li><li><strong><code>net.core.wmem_max</code></strong>：所有类型 Socket 的最大发送缓冲区大小（字节）。</li><li><strong><code>net.core.rmem_default</code></strong>：所有类型 Socket 的默认接收缓冲区大小。</li><li><strong><code>net.core.wmem_default</code></strong>：所有类型 Socket 的默认发送缓冲区大小。</li></ul><p><em>推荐示例（适用于 10Gbps+ 环境）：</em></p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 临时设置（重启后失效）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sysctl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -w</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> net.core.rmem_max=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">67108864</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   # 64 MB</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sysctl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -w</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> net.core.wmem_max=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">67108864</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   # 64 MB</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sysctl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -w</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> net.core.rmem_default=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">67108864</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sysctl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -w</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> net.core.wmem_default=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">67108864</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 如需永久生效，请添加到 /etc/sysctl.conf 文件</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># net.core.rmem_max = 67108864</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># net.core.wmem_max = 67108864</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># net.core.rmem_default = 67108864</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># net.core.wmem_default = 67108864</span></span></code></pre></div><h3 id="监控-udp-缓冲区溢出" tabindex="-1">监控 UDP 缓冲区溢出： <a class="header-anchor" href="#监控-udp-缓冲区溢出" aria-label="Permalink to “监控 UDP 缓冲区溢出：”">​</a></h3><p>使用 <code>netstat -su</code> 或 <code>ss -su</code> 监控接收和发送缓冲区错误。查找“receive buffer errors”或“packets dropped”计数。这也是<a href="/zh-CN/operations_guide#监控">运维指南</a>中排查丢包问题的重要步骤。</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">netstat</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -su</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Udp:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#     ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#     65535 packets dropped</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#     ...</span></span></code></pre></div><h2 id="cpu-亲和性与中断" tabindex="-1">CPU 亲和性与中断 <a class="header-anchor" href="#cpu-亲和性与中断" aria-label="Permalink to “CPU 亲和性与中断”">​</a></h2><p>网络数据包处理，特别是在多核系统上，可以通过 CPU 绑定（CPU pinning）和中断平衡得到显著改善。</p><h3 id="网闸连接器进程的-cpu-亲和性" tabindex="-1">网闸连接器进程的 CPU 亲和性： <a class="header-anchor" href="#网闸连接器进程的-cpu-亲和性" aria-label="Permalink to “网闸连接器进程的 CPU 亲和性：”">​</a></h3><p>为网闸连接器<a href="/zh-CN/software_architecture">入口代理/出口代理</a>进程分配专用的 CPU 核心。这减少了上下文切换，并确保网闸连接器独占 CPU 资源。</p><p><em>示例（将进程绑定到 CPU 1 和 2）：</em></p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> taskset</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -c</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1,2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ddc_进程I</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><h3 id="中断请求-irq-亲和性" tabindex="-1">中断请求 (IRQ) 亲和性： <a class="header-anchor" href="#中断请求-irq-亲和性" aria-label="Permalink to “中断请求 (IRQ) 亲和性：”">​</a></h3><p>确保网卡中断由专用的 CPU 核心处理，最好与运行 DDC 进程的 CPU 核心不同。这可以防止 DDC 应用程序与网卡中断争夺 CPU 时间。<code>irqbalance</code> 等工具可以自动化此过程，但对于关键的高性能设置，可能需要通过 <code>/proc/irq/&lt;IRQ_NUMBER&gt;/smp_affinity</code> 进行手动绑定。</p><h2 id="网卡-nic-卸载" tabindex="-1">网卡 (NIC) 卸载 <a class="header-anchor" href="#网卡-nic-卸载" aria-label="Permalink to “网卡 (NIC) 卸载”">​</a></h2><p>现代网卡可以从 CPU 卸载各种任务，显著提高网络性能。然而，如果网闸连接器在原始数据包级别进行<a href="/zh-CN/security_model#内容过滤与净化-dpi">深度包检测 (DPI)</a>，某些卸载功能可能会产生干扰。对于网闸连接器当前的模型（协议处理器处理已接收到的应用层数据），卸载通常是有益的。</p><h3 id="关键-ethtool-参数" tabindex="-1">关键 <code>ethtool</code> 参数： <a class="header-anchor" href="#关键-ethtool-参数" aria-label="Permalink to “关键 ethtool 参数：”">​</a></h3><ul><li><strong>通用接收卸载 (Generic Receive Offload, GRO)</strong>：在将多个传入数据包传递给内核之前，将其整合为更大的“超级数据包”。这减少了内核需要处理的数据包数量。</li><li><strong>通用分段卸载 (Generic Segmentation Offload, GSO)</strong>：对传出数据包执行相反操作，允许网闸连接器发送大的数据块，然后网卡将其分段为多个较小的数据包。</li><li><strong>校验和卸载 (Checksum Offload, Tx/Rx)</strong>：网卡而不是 CPU 来计算/验证校验和。</li></ul><p><em>示例（检查状态并启用）：</em></p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 检查接口（例如 eth0）的当前状态</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ethtool</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -k</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eth0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 启用 GRO/GSO/校验和（通常默认启用）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ethtool</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -K</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eth0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> gro</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> on</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> gso</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> on</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tx-checksum-ip-generic</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> on</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rx-checksum-ip-generic</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> on</span></span></code></pre></div><h2 id="中断合并-interrupt-coalescing" tabindex="-1">中断合并 (Interrupt Coalescing) <a class="header-anchor" href="#中断合并-interrupt-coalescing" aria-label="Permalink to “中断合并 (Interrupt Coalescing)”">​</a></h2><p>中断合并将网卡产生的多个硬件中断合并为一个 CPU 中断。这减少了 CPU 开销，但可能会略微增加延迟。</p><h3 id="关键-ethtool-参数-1" tabindex="-1">关键 <code>ethtool</code> 参数： <a class="header-anchor" href="#关键-ethtool-参数-1" aria-label="Permalink to “关键 ethtool 参数：”">​</a></h3><ul><li><strong><code>rx-frames</code></strong>：在生成中断之前接收到的帧数。</li><li><strong><code>rx-usecs</code></strong>：在生成中断之前等待的微秒数。</li></ul><p>调整这些参数是一个权衡过程：较高的值（更积极的合并）导致较低的 CPU 利用率但较高的延迟；较低的值（较少的合并）导致较高的 CPU 利用率但较低的延迟。对于网闸连接器，特别是在 <a href="/zh-CN/flow_control#第四步-处理-0-的陷阱"><code>send_delay_ms=0</code></a> 时，平衡至关重要。</p><p><em>示例（调整合并）：</em></p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 检查当前设置</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ethtool</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -c</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eth0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 设置自定义值（例如，更积极的合并）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ethtool</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -C</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eth0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rx-frames</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 256</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rx-usecs</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 250</span></span></code></pre></div><h2 id="巨型帧-jumbo-frames" tabindex="-1">巨型帧 (Jumbo Frames) <a class="header-anchor" href="#巨型帧-jumbo-frames" aria-label="Permalink to “巨型帧 (Jumbo Frames)”">​</a></h2><p>如果您的整个网络路径（网卡、交换机、路由器）都支持巨型帧（更大的 MTU，例如 9000 字节而非 1500），则可以减少数据包开销和 CPU 周期，因为每个数据包可以承载更多数据。</p><p><em>示例（将 MTU 设置为 9000）：</em></p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> link</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dev</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eth0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mtu</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 9000</span></span></code></pre></div><blockquote><p><strong>警告</strong>：确保路径中的所有设备都支持更大的 MTU，否则数据包将被分段或丢弃，导致性能下降。</p></blockquote><h2 id="监控工具" tabindex="-1">监控工具 <a class="header-anchor" href="#监控工具" aria-label="Permalink to “监控工具”">​</a></h2><p>为了有效调优，持续监控至关重要：</p><ul><li><strong><code>netstat -su</code> / <code>ss -su</code></strong>：UDP 数据包统计信息，包括丢弃的数据包。</li><li><strong><code>sar -n UDP 1</code></strong>：实时 UDP 流量和错误。</li><li><strong><code>mpstat -P ALL 1</code></strong>：每个 CPU 的利用率。</li><li><strong><code>top</code> / <code>htop</code></strong>：整体系统资源使用情况。</li><li><strong><code>dmesg</code></strong>：内核日志中与网络相关的错误。</li><li><strong><code>/proc/interrupts</code></strong>：每个 CPU 的中断计数。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h2><p>优化网闸连接器性能，特别是在高吞吐量场景下，超越了<a href="/zh-CN/configuration_reference">应用层配置</a>的范畴。通过战略性地调整与 UDP 缓冲、CPU 调度、网卡卸载和中断处理相关的内核参数，管理员可以充分发挥其硬件的潜力，实现跨网闸的可靠、高速数据传输。请务必在受控环境中彻底测试所有更改。</p>`,43)])])}const g=i(t,[["render",l]]);export{c as __pageData,g as default};
