import{_ as t,c as a,o as i,a6 as s}from"./chunks/framework.Cpr3xyXy.js";const g=JSON.parse('{"title":"DDC UDP Protocol Specification - Headers & Fragmentation","description":"Technical specification for the Data Diode Connector (DDC) custom UDP protocol. Details the 9-byte header, packet fragmentation logic, sequence numbering for loss detection, and the receiver state machine.","frontmatter":{"title":"DDC UDP Protocol Specification - Headers & Fragmentation","description":"Technical specification for the Data Diode Connector (DDC) custom UDP protocol. Details the 9-byte header, packet fragmentation logic, sequence numbering for loss detection, and the receiver state machine.","head":[["meta",{"name":"keywords","content":"UDP Protocol Spec, Packet Header, Fragmentation, Sequence Number, Packet Loss Detection, State Machine, Custom Protocol"}]],"seo":{"proficiencyLevel":"Advanced","keywords":["UDP Protocol Specification","Packet Fragmentation","Sequence Numbering","Finite State Machine","Reliable UDP"]}},"headers":[],"relativePath":"en/protocol.md","filePath":"en/protocol.md","lastUpdated":1764595667000}'),n={name:"en/protocol.md"};function o(r,e,c,l,d,p){return i(),a("div",null,[...e[0]||(e[0]=[s(`<h1 id="udp-transport-protocol-specification" tabindex="-1">UDP Transport Protocol Specification <a class="header-anchor" href="#udp-transport-protocol-specification" aria-label="Permalink to “UDP Transport Protocol Specification”">​</a></h1><p>Version: <code>1.0</code></p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to “Overview”">​</a></h2><p>The Data Diode Connector (DDC) utilizes a custom, lightweight application-layer protocol on top of UDP for communication between the <strong><a href="/en/software_architecture">Ingress Proxy and Egress Proxy components</a></strong>. This protocol is designed to reliably transport large, opaque binary data chunks across the data diode by splitting them into smaller UDP packets and reassembling them on the receiving end.</p><p>The protocol provides the following key features:</p><ul><li><strong>Message Fragmentation and Reassembly</strong>: Allows transmission of data chunks larger than the standard UDP payload size.</li><li><strong>Packet Loss Detection</strong>: Uses a sequential numbering system to detect lost packets.</li><li><strong>Connection Lifecycle Management</strong>: Includes special message types for startup, shutdown, and keep-alive.</li></ul><h2 id="packet-structure" tabindex="-1">Packet Structure <a class="header-anchor" href="#packet-structure" aria-label="Permalink to “Packet Structure”">​</a></h2><p>Every UDP packet exchanged between the transport components follows a fixed header structure, followed by a variable-length payload.</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span> 0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|  Message Type |               Sequence Number                 |</span></span>
<span class="line"><span>|               |                (LSB, 24 bits)                 |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>|Sequence Number|         Payload Length        | Remaining Pkts|</span></span>
<span class="line"><span>| (MSB, 8 bits) |         (Little-Endian)       |     (LSB)     |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span>
<span class="line"><span>| Remaining Pkts|                                               |</span></span>
<span class="line"><span>|     (MSB)     |                   (Padding)                   |</span></span>
<span class="line"><span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code></pre></div><h3 id="header-fields" tabindex="-1">Header Fields <a class="header-anchor" href="#header-fields" aria-label="Permalink to “Header Fields”">​</a></h3><p>The header has a fixed size of <strong>9 bytes</strong>.</p><ul><li><p><strong>Message Type</strong> (1 byte)</p><ul><li>An 8-bit unsigned integer that defines the purpose of the packet. See <a href="#message-types">Message Types</a> for details.</li></ul></li><li><p><strong>Sequence Number</strong> (4 bytes)</p><ul><li>A 32-bit unsigned integer in <strong>Little-Endian</strong> format.</li><li>This number increments by one for every packet sent.</li><li>It is used by the receiver to detect packet loss. The sequence number <code>0</code> is a special case and does not indicate packet loss when received out of order (e.g., after a <code>StartUp</code> message).</li></ul></li><li><p><strong>Payload Length</strong> (2 bytes)</p><ul><li>A 16-bit unsigned integer in <strong>Little-Endian</strong> format.</li><li>Specifies the size of the <code>Payload</code> field in bytes for the current packet.</li><li>For <code>Data</code> and <code>DataFirst</code> packets, this value is typically the maximum payload size (<code>MAX_PAYLOAD_SIZE_BYTES</code>), except for the very last packet of a fragmented message, which may be smaller.</li></ul></li><li><p><strong>Remaining Packets</strong> (2 bytes)</p><ul><li>A 16-bit unsigned integer in <strong>Little-Endian</strong> format.</li><li>Indicates how many packets are <strong>left</strong> to be received to complete the current data chunk.</li><li>For a <code>DataFirst</code> packet, this value represents the total number of subsequent packets for that chunk.</li><li>For a <code>Data</code> packet, this value decrements with each packet received.</li><li>When this value is <code>0</code>, it signifies that the current packet is the final one for the data chunk.</li></ul></li></ul><h3 id="payload" tabindex="-1">Payload <a class="header-anchor" href="#payload" aria-label="Permalink to “Payload”">​</a></h3><ul><li><strong>Payload</strong> (Variable size) <ul><li>The raw binary data segment of the original data chunk.</li><li>The size of this field is defined by the <code>Payload Length</code> header field.</li></ul></li></ul><h2 id="message-types" tabindex="-1">Message Types <a class="header-anchor" href="#message-types" aria-label="Permalink to “Message Types”">​</a></h2><p>The <code>Message Type</code> field dictates how the receiver processes the packet.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Value</th><th style="text-align:left;">Name</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;"><code>0</code></td><td style="text-align:left;"><code>DataFirst</code></td><td style="text-align:left;">Marks the first packet of a new data chunk. The receiver transitions from <code>WaitingForFirstData</code> to <code>WaitingForData</code> state and uses the <code>Remaining Packets</code> field to know how many more packets to expect.</td></tr><tr><td style="text-align:left;"><code>1</code></td><td style="text-align:left;"><code>Data</code></td><td style="text-align:left;">A subsequent packet of a fragmented data chunk. The receiver collects these packets until <code>Remaining Packets</code> is zero, then reassembles the full chunk.</td></tr><tr><td style="text-align:left;"><code>2</code></td><td style="text-align:left;"><code>StartUp</code></td><td style="text-align:left;">A control message sent when the sender initializes. On receipt, the receiver resets its expected sequence number to <code>0</code> and returns to the <code>WaitingForFirstData</code> state, discarding any partially received data.</td></tr><tr><td style="text-align:left;"><code>3</code></td><td style="text-align:left;"><code>HeartBeat</code></td><td style="text-align:left;">A <a href="/en/deployment_topologies#heartbeat-detection">keep-alive message</a>. The receiver logs its reception and remains in its current state. It does not affect data processing.</td></tr><tr><td style="text-align:left;"><code>4</code></td><td style="text-align:left;"><code>Shutdown</code></td><td style="text-align:left;">A control message indicating the sender is shutting down. On receipt, the receiver will terminate its processing loop.</td></tr></tbody></table><h2 id="state-machine-and-reassembly-logic" tabindex="-1">State Machine and Reassembly Logic <a class="header-anchor" href="#state-machine-and-reassembly-logic" aria-label="Permalink to “State Machine and Reassembly Logic”">​</a></h2><p>The receiver operates as a state machine to handle packet reassembly.</p><ol><li><p><strong>Initial State: <code>WaitingForFirstData</code></strong></p><ul><li>The receiver is idle, waiting for a new data transmission to begin.</li><li>It only accepts <code>DataFirst</code>, <code>StartUp</code>, <code>HeartBeat</code>, or <code>Shutdown</code> packets. Any <code>Data</code> packets are discarded.</li></ul></li><li><p><strong>Receiving <code>DataFirst</code></strong></p><ul><li>When a <code>DataFirst</code> packet arrives, the receiver stores its payload as the first part of a new message.</li><li>If <code>Remaining Packets</code> is <code>0</code>, the message is complete. The payload is written to the output buffer, and the state remains <code>WaitingForFirstData</code>.</li><li>If <code>Remaining Packets</code> is greater than <code>0</code>, the receiver transitions to the <code>WaitingForData(N)</code> state, where <code>N</code> is the total number of packets for this message (<code>Remaining Packets</code> + 1).</li></ul></li><li><p><strong>State: <code>WaitingForData(N)</code></strong></p><ul><li>The receiver is actively collecting packets for a fragmented message.</li><li>It expects <code>N-1</code> subsequent <code>Data</code> packets.</li><li>Each incoming <code>Data</code> packet&#39;s payload is stored in an intermediate buffer based on its position in the sequence (calculated using the <code>Remaining Packets</code> value).</li><li>If a <code>DataFirst</code> packet is received unexpectedly in this state, the current reassembly is aborted, the partial data is discarded, and a new reassembly begins with this new packet.</li></ul></li><li><p><strong>Receiving the Final <code>Data</code> Packet</strong></p><ul><li>When a <code>Data</code> packet arrives with <code>Remaining Packets</code> equal to <code>0</code>, it signals the end of the message.</li><li>The receiver combines all stored payloads from the intermediate buffer into a single, contiguous byte array.</li><li>This reassembled data chunk is then written to the output <a href="/en/software_architecture#lock-free-buffering-bipbuffer"><code>bip_buffer</code></a> for the downstream component.</li><li>The state machine transitions back to <code>WaitingForFirstData</code>.</li></ul></li><li><p><strong>Packet Loss Handling</strong></p><ul><li>At every received packet, the receiver compares the packet&#39;s <code>Sequence Number</code> with its expected sequence number.</li><li>If <code>incoming &gt; expected</code>, the receiver detects that one or more packets have been lost.</li><li>When packet loss is detected, the receiver <strong>aborts the current message reassembly</strong>, discards any buffered data for that message, and resets its state to <code>WaitingForFirstData</code>. This ensures that corrupted or incomplete data chunks are not forwarded.</li></ul></li></ol>`,20)])])}const u=t(n,[["render",o]]);export{g as __pageData,u as default};
